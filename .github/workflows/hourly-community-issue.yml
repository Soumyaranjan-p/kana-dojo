name: Create Community Contribution Issue

on:
  schedule:
    - cron: '*/15 * * * *'
  workflow_dispatch:
    inputs:
      force_type:
        description: 'Force issue type: theme | fact | proverb | trivia | grammar | animeQuote'
        required: false
        type: string
      dry_run:
        description: 'Do not create an issue; only log selection'
        required: false
        type: boolean

permissions:
  contents: read
  issues: write

# Prevent multiple runs from overlapping and causing race conditions
concurrency:
  group: community-issue-creation
  cancel-in-progress: true

jobs:
  create-issue:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    if: github.repository == 'lingdojo/kana-dojo'
    env:
      AUTOMATION_PR_TOKEN: ${{ secrets.AUTOMATION_PR_TOKEN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          persist-credentials: false

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Create community issue
        id: create-issue
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const templates = require('./.github/templates/messages.cjs');
            const t = templates.issueCreation;

            const forceType = (context.payload.inputs && context.payload.inputs.force_type) ? String(context.payload.inputs.force_type).trim() : '';
            const dryRun = !!(context.payload.inputs && (context.payload.inputs.dry_run === true || context.payload.inputs.dry_run === 'true'));

            const emojiBank = [
              // Art & Creativity
              'ðŸŽ¨', 'ðŸ–Œï¸', 'ðŸ–ï¸', 'âœï¸', 'ðŸ“', 'ðŸŽ­', 'ðŸŽª', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§',
              'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸŽ·', 'ðŸŽº', 'ðŸŽ¸', 'ðŸŽ»', 'ðŸŽ²', 'ðŸŽ¯', 'ðŸŽ³',
              'ðŸŽ®', 'ðŸŽ°', 'ðŸ§©', 'ðŸ§¸', 'ðŸª€', 'ðŸª', 'ðŸŽ ', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸ›',

              // Nature & Weather
              'ðŸŒ¸', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¼', 'ðŸŒ·', 'ðŸŒ¹', 'ðŸ¥€', 'ðŸª»', 'ðŸª·', 'â˜˜ï¸',
              'ðŸ€', 'ðŸŒ¿', 'ðŸŒ±', 'ðŸŒ²', 'ðŸŒ³', 'ðŸŒ´', 'ðŸŒµ', 'ðŸŒ¾', 'ðŸŒ°', 'ðŸ„',
              'ðŸ', 'ðŸ‚', 'ðŸƒ', 'ðŸŒŠ', 'ðŸ”¥', 'ðŸ’§', 'â„ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¬ï¸',
              'ðŸ’¨', 'ðŸŒªï¸', 'ðŸŒ«ï¸', 'â˜€ï¸', 'ðŸŒ¤ï¸', 'â›…', 'ðŸŒ¥ï¸', 'â˜ï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸',
              'â›ˆï¸', 'ðŸŒ©ï¸', 'âš¡', 'ðŸŒˆ', 'â˜”', 'ðŸ’¦', 'â˜‚ï¸', 'ðŸŒ™', 'ðŸŒ•', 'ðŸŒ–',
              'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒš', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ',
              'â­', 'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'â˜„ï¸', 'ðŸŒ', 'ðŸŒŽ', 'ðŸŒ', 'ðŸŒ‹', 'ðŸ—»',

              // Food & Drink
              'ðŸœ', 'ðŸ', 'ðŸ•', 'ðŸ”', 'ðŸŸ', 'ðŸŒ­', 'ðŸ¥ª', 'ðŸŒ®', 'ðŸŒ¯', 'ðŸ«”',
              'ðŸ¥™', 'ðŸ§†', 'ðŸ¥š', 'ðŸ³', 'ðŸ¥˜', 'ðŸ²', 'ðŸ«•', 'ðŸ¥£', 'ðŸ¥—', 'ðŸ¿',
              'ðŸ§ˆ', 'ðŸ§‚', 'ðŸ¥«', 'ðŸ±', 'ðŸ˜', 'ðŸ™', 'ðŸš', 'ðŸ›', 'ðŸœ', 'ðŸ',
              'ðŸ ', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¡', 'ðŸ¦', 'ðŸ§', 'ðŸ¨', 'ðŸ©',
              'ðŸª', 'ðŸŽ‚', 'ðŸ°', 'ðŸ§', 'ðŸ¥§', 'ðŸ«', 'ðŸ¬', 'ðŸ­', 'ðŸ®', 'ðŸ¯',
              'ðŸ¼', 'ðŸ¥›', 'â˜•', 'ðŸ«–', 'ðŸµ', 'ðŸ§ƒ', 'ðŸ¥¤', 'ðŸ§‹', 'ðŸ¶', 'ðŸº',
              'ðŸ»', 'ðŸ¥‚', 'ðŸ·', 'ðŸ¥ƒ', 'ðŸ¸', 'ðŸ¹', 'ðŸ§‰', 'ðŸ¾', 'ðŸ§Š', 'ðŸ¥„',
              'ðŸ´', 'ðŸ½ï¸', 'ðŸ¥£', 'ðŸ¥¡', 'ðŸ¥¢', 'ðŸ§‚', 'ðŸ’', 'ðŸ‘', 'ðŸ', 'ðŸ¥',
              'ðŸ¥‘', 'ðŸ…', 'ðŸ†', 'ðŸ¥’', 'ðŸ¥¬', 'ðŸ¥¦', 'ðŸ§„', 'ðŸ§…', 'ðŸ„', 'ðŸ¥œ',
              'ðŸŒ°', 'ðŸž', 'ðŸ¥', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ¥¯', 'ðŸ¥ž', 'ðŸ§‡', 'ðŸ§€', 'ðŸ–',
              'ðŸ—', 'ðŸ¥©', 'ðŸ¥“', 'ðŸ”', 'ðŸŸ', 'ðŸ•', 'ðŸŒ­', 'ðŸ¥ª', 'ðŸŒ®', 'ðŸŒ¯',

              // Animals
              'ðŸ¶', 'ðŸ•', 'ðŸ¦®', 'ðŸ•â€ðŸ¦º', 'ðŸ©', 'ðŸº', 'ðŸ¦Š', 'ðŸ¦', 'ðŸ±', 'ðŸˆ',
              'ðŸˆâ€â¬›', 'ðŸ¦', 'ðŸ¯', 'ðŸ…', 'ðŸ†', 'ðŸ´', 'ðŸŽ', 'ðŸ¦„', 'ðŸ¦“', 'ðŸ¦Œ',
              'ðŸ¦¬', 'ðŸ®', 'ðŸ‚', 'ðŸƒ', 'ðŸ„', 'ðŸ·', 'ðŸ–', 'ðŸ—', 'ðŸ½', 'ðŸ',
              'ðŸ‘', 'ðŸ', 'ðŸª', 'ðŸ«', 'ðŸ¦™', 'ðŸ¦’', 'ðŸ˜', 'ðŸ¦£', 'ðŸ¦', 'ðŸ¦›',
              'ðŸ­', 'ðŸ', 'ðŸ€', 'ðŸ¹', 'ðŸ°', 'ðŸ‡', 'ðŸ¿ï¸', 'ðŸ¦«', 'ðŸ¦”', 'ðŸ¦‡',
              'ðŸ»', 'ðŸ»â€â„ï¸', 'ðŸ¨', 'ðŸ¼', 'ðŸ¦¥', 'ðŸ¦¦', 'ðŸ¦¨', 'ðŸ¦˜', 'ðŸ¦¡', 'ðŸ¾',
              'ðŸ¦ƒ', 'ðŸ”', 'ðŸ“', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ§', 'ðŸ•Šï¸', 'ðŸ¦…',
              'ðŸ¦†', 'ðŸ¦¢', 'ðŸ¦‰', 'ðŸ¦¤', 'ðŸª¶', 'ðŸ¦©', 'ðŸ¦š', 'ðŸ¦œ', 'ðŸ¸', 'ðŸŠ',
              'ðŸ¢', 'ðŸ¦Ž', 'ðŸ', 'ðŸ²', 'ðŸ‰', 'ðŸ¦•', 'ðŸ¦–', 'ðŸ³', 'ðŸ‹', 'ðŸ¬',
              'ðŸ¦­', 'ðŸŸ', 'ðŸ ', 'ðŸ¡', 'ðŸ¦ˆ', 'ðŸ™', 'ðŸš', 'ðŸª¸', 'ðŸª¼', 'ðŸŒ',
              'ðŸ¦‹', 'ðŸ›', 'ðŸœ', 'ðŸ', 'ðŸª²', 'ðŸž', 'ðŸ¦—', 'ðŸª³', 'ðŸ•·ï¸', 'ðŸ•¸ï¸',
              'ðŸ¦‚', 'ðŸ¦Ÿ', 'ðŸª°', 'ðŸª±', 'ðŸ¦ ', 'ðŸ’', 'ðŸŒ¸', 'ðŸ’®', 'ðŸµï¸', 'ðŸŒ¹',

              // Objects & Items
              'ðŸ“±', 'ðŸ“²', 'â˜Žï¸', 'ðŸ“ž', 'ðŸ“Ÿ', 'ðŸ“ ', 'ðŸ”‹', 'ðŸ”Œ', 'ðŸ’»', 'ðŸ–¥ï¸',
              'ðŸ–¨ï¸', 'âŒ¨ï¸', 'ðŸ–±ï¸', 'ðŸ–²ï¸', 'ðŸ’½', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ“€', 'ðŸ§®', 'ðŸŽ¥',
              'ðŸŽžï¸', 'ðŸ“½ï¸', 'ðŸŽ¬', 'ðŸ“º', 'ðŸ“·', 'ðŸ“¸', 'ðŸ“¹', 'ðŸ“¼', 'ðŸ”', 'ðŸ”Ž',
              'ðŸ•¯ï¸', 'ðŸ’¡', 'ðŸ”¦', 'ðŸ®', 'ðŸª”', 'ðŸ“”', 'ðŸ“•', 'ðŸ“–', 'ðŸ“—', 'ðŸ“˜',
              'ðŸ“™', 'ðŸ“š', 'ðŸ““', 'ðŸ“’', 'ðŸ“ƒ', 'ðŸ“œ', 'ðŸ“„', 'ðŸ“°', 'ðŸ—žï¸', 'ðŸ“‘',
              'ðŸ”–', 'ðŸ·ï¸', 'ðŸ’°', 'ðŸª™', 'ðŸ’´', 'ðŸ’µ', 'ðŸ’¶', 'ðŸ’·', 'ðŸ’¸', 'ðŸ’³',
              'ðŸ§¾', 'âœ‰ï¸', 'ðŸ“§', 'ðŸ“¨', 'ðŸ“©', 'ðŸ“¤', 'ðŸ“¥', 'ðŸ“¦', 'ðŸ“«', 'ðŸ“ª',
              'ðŸ“¬', 'ðŸ“­', 'ðŸ“®', 'ðŸ—³ï¸', 'âœï¸', 'âœ’ï¸', 'ðŸ–‹ï¸', 'ðŸ–Šï¸', 'ðŸ–Œï¸', 'ðŸ–ï¸',
              'ðŸ“', 'ðŸ’¼', 'ðŸ“', 'ðŸ“‚', 'ðŸ—‚ï¸', 'ðŸ“…', 'ðŸ“†', 'ðŸ—’ï¸', 'ðŸ—“ï¸', 'ðŸ“‡',
              'ðŸ“ˆ', 'ðŸ“‰', 'ðŸ“Š', 'ðŸ“‹', 'ðŸ“Œ', 'ðŸ“', 'ðŸ“Ž', 'ðŸ–‡ï¸', 'ðŸ“', 'ðŸ“',
              'âœ‚ï¸', 'ðŸ—ƒï¸', 'ðŸ—„ï¸', 'ðŸ—‘ï¸', 'ðŸ”’', 'ðŸ”“', 'ðŸ”', 'ðŸ”', 'ðŸ”‘', 'ðŸ—ï¸',
              'ðŸ”¨', 'ðŸª“', 'â›ï¸', 'âš’ï¸', 'ðŸ› ï¸', 'ðŸ—¡ï¸', 'âš”ï¸', 'ðŸ”«', 'ðŸªƒ', 'ðŸ¹',
              'ðŸ›¡ï¸', 'ðŸªš', 'ðŸ”§', 'ðŸª›', 'ðŸ”©', 'âš™ï¸', 'ðŸ—œï¸', 'âš–ï¸', 'ðŸ¦¯', 'ðŸ”—',
              'â›“ï¸', 'ðŸª', 'ðŸ§°', 'ðŸ§²', 'ðŸªœ', 'ðŸ§ª', 'ðŸ§«', 'ðŸ§¬', 'ðŸ”¬', 'ðŸ”­',
              'ðŸ“¡', 'ðŸ’‰', 'ðŸ©¸', 'ðŸ’Š', 'ðŸ©¹', 'ðŸ©¼', 'ðŸ©º', 'ðŸŒ¡ï¸', 'ðŸ§¹', 'ðŸª ',
              'ðŸ§º', 'ðŸ§»', 'ðŸš½', 'ðŸš°', 'ðŸš¿', 'ðŸ›', 'ðŸ›€', 'ðŸ§¼', 'ðŸª¥', 'ðŸª’',
              'ðŸ§½', 'ðŸª£', 'ðŸ§´', 'ðŸ›Žï¸', 'ðŸ”‘', 'ðŸ—ï¸', 'ðŸšª', 'ðŸª‘', 'ðŸ›‹ï¸', 'ðŸ›ï¸',
              'ðŸ›Œ', 'ðŸ§¸', 'ðŸ–¼ï¸', 'ðŸªž', 'ðŸªŸ', 'ðŸ›ï¸', 'ðŸ›’', 'ðŸŽ', 'ðŸŽˆ', 'ðŸŽ',
              'ðŸŽ€', 'ðŸª„', 'ðŸª…', 'ðŸŽŠ', 'ðŸŽ‰', 'ðŸŽŽ', 'ðŸ†', 'ðŸŽ–ï¸', 'ðŸ…', 'ðŸ¥‡',
              'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸŽ—ï¸', 'ðŸµï¸', 'ðŸŽ«', 'ðŸŽŸï¸', 'ðŸŽª', 'ðŸ¤¹', 'ðŸŽ­', 'ðŸ©°',
              'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§', 'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸª˜', 'ðŸŽ·', 'ðŸŽº',
              'ðŸª—', 'ðŸŽ¸', 'ðŸª•', 'ðŸŽ»', 'ðŸª•', 'ðŸŽ²', 'â™Ÿï¸', 'ðŸŽ¯', 'ðŸŽ³', 'ðŸŽ®',
              'ðŸŽ°', 'ðŸ§©', 'ðŸ§¸', 'ðŸª†', 'â™ ï¸', 'â™¥ï¸', 'â™¦ï¸', 'â™£ï¸', 'â™Ÿï¸', 'ðŸƒ',
              'ðŸ€„', 'ðŸŽ´', 'ðŸŽ­', 'ðŸ–¼ï¸', 'ðŸŽ¨', 'ðŸ§µ', 'ðŸª¡', 'ðŸ§¶', 'ðŸª¢', 'ðŸ‘“',
              'ðŸ•¶ï¸', 'ðŸ¥½', 'ðŸ¥¼', 'ðŸ¦º', 'ðŸ‘”', 'ðŸ‘•', 'ðŸ‘–', 'ðŸ§£', 'ðŸ§¤', 'ðŸ§¥',
              'ðŸ§¦', 'ðŸ‘—', 'ðŸ‘˜', 'ðŸ¥»', 'ðŸ©±', 'ðŸ©²', 'ðŸ©³', 'ðŸ‘™', 'ðŸ‘š', 'ðŸ‘›',
              'ðŸ‘œ', 'ðŸ‘', 'ðŸ›ï¸', 'ðŸŽ’', 'ðŸ©´', 'ðŸ‘ž', 'ðŸ‘Ÿ', 'ðŸ¥¾', 'ðŸ¥¿', 'ðŸ‘ ',
              'ðŸ‘¡', 'ðŸ©°', 'ðŸ‘¢', 'ðŸ‘‘', 'ðŸ‘’', 'ðŸŽ©', 'ðŸŽ“', 'ðŸ§¢', 'ðŸª–', 'â›‘ï¸',
              'ðŸ“¿', 'ðŸ’„', 'ðŸ’', 'ðŸ’Ž', 'ðŸ”‡', 'ðŸ”ˆ', 'ðŸ”‰', 'ðŸ”Š', 'ðŸ“¢', 'ðŸ“£',
              'ðŸ“¯', 'ðŸ””', 'ðŸ”•', 'ðŸŽ¼', 'ðŸŽµ', 'ðŸŽ¶', 'ðŸŽ™ï¸', 'ðŸŽšï¸', 'ðŸŽ›ï¸', 'ðŸŽ¤',
              'ðŸŽ§', 'ðŸ“»', 'ðŸŽ·', 'ðŸŽ¸', 'ðŸŽ¹', 'ðŸŽº', 'ðŸŽ»', 'ðŸª•', 'ðŸ¥', 'ðŸª˜',

              // Symbols & Shapes
              'â¤ï¸', 'ðŸ§¡', 'ðŸ’›', 'ðŸ’š', 'ðŸ’™', 'ðŸ’œ', 'ðŸ–¤', 'ðŸ¤', 'ðŸ¤Ž', 'ðŸ’”',
              'â£ï¸', 'ðŸ’•', 'ðŸ’ž', 'ðŸ’“', 'ðŸ’—', 'ðŸ’–', 'ðŸ’˜', 'ðŸ’', 'ðŸ’Ÿ', 'â˜®ï¸',
              'âœï¸', 'â˜ªï¸', 'ðŸ•‰ï¸', 'â˜¸ï¸', 'âœ¡ï¸', 'ðŸ”¯', 'ðŸ•Ž', 'â˜¯ï¸', 'â˜¦ï¸', 'ðŸ›',
              'â›Ž', 'â™ˆ', 'â™‰', 'â™Š', 'â™‹', 'â™Œ', 'â™', 'â™Ž', 'â™', 'â™',
              'â™‘', 'â™’', 'â™“', 'ðŸ†”', 'âš›ï¸', 'ðŸ‰‘', 'â˜¢ï¸', 'â˜£ï¸', 'ðŸ“´', 'ðŸ“³',
              'ðŸˆ¶', 'ðŸˆš', 'ðŸˆ¸', 'ðŸˆº', 'ðŸˆ·ï¸', 'âœ´ï¸', 'ðŸ†š', 'ðŸ’®', 'ðŸ‰', 'ãŠ™ï¸',
              'ãŠ—ï¸', 'ðŸˆ´', 'ðŸˆµ', 'ðŸˆ¹', 'ðŸˆ²', 'ðŸ…°ï¸', 'ðŸ…±ï¸', 'ðŸ†Ž', 'ðŸ†‘', 'ðŸ…¾ï¸',
              'ðŸ†˜', 'âŒ', 'â­•', 'ðŸ›‘', 'â›”', 'ðŸ“›', 'ðŸš«', 'ðŸ’¯', 'ðŸ’¢', 'â™¨ï¸',
              'ðŸš·', 'ðŸš¯', 'ðŸš³', 'ðŸš±', 'ðŸ”ž', 'ðŸ“µ', 'ðŸš­', 'â—', 'â•', 'â“',
              'â”', 'â€¼ï¸', 'â‰ï¸', 'ðŸ”…', 'ðŸ”†', 'ã€½ï¸', 'âš ï¸', 'ðŸš¸', 'ðŸ”±', 'âšœï¸',
              'ðŸ”°', 'â™»ï¸', 'âœ…', 'ðŸˆ¯', 'ðŸ’¹', 'â‡ï¸', 'âœ³ï¸', 'âŽ', 'ðŸŒ', 'ðŸ’ ',
              'â“‚ï¸', 'ðŸŒ€', 'ðŸ’¤', 'ðŸ§', 'ðŸš¾', 'â™¿', 'ðŸ…¿ï¸', 'ðŸˆ³', 'ðŸˆ‚', 'ðŸ›‚',
              'ðŸ›ƒ', 'ðŸ›„', 'ðŸ›…', 'ðŸ›—', 'ðŸ§', 'ðŸš¾', 'âš§ï¸', 'â™‚ï¸', 'â™€ï¸', 'âš•ï¸',

              // Transportation & Places
              'ðŸš—', 'ðŸš•', 'ðŸš™', 'ðŸšŒ', 'ðŸšŽ', 'ðŸŽï¸', 'ðŸš“', 'ðŸš‘', 'ðŸš’', 'ðŸš',
              'ðŸ›»', 'ðŸšš', 'ðŸš›', 'ðŸšœ', 'ðŸ¦¯', 'ðŸ¦½', 'ðŸ¦¼', 'ðŸ›´', 'ðŸš²', 'ðŸ›µ',
              'ðŸï¸', 'ðŸ›º', 'ðŸš¨', 'ðŸš”', 'ðŸš', 'ðŸš˜', 'ðŸš–', 'ðŸš¡', 'ðŸš ', 'ðŸšŸ',
              'ðŸšƒ', 'ðŸš‹', 'ðŸšž', 'ðŸš', 'ðŸš„', 'ðŸš…', 'ðŸšˆ', 'ðŸš‚', 'ðŸš†', 'ðŸš‡',
              'ðŸšŠ', 'ðŸš‰', 'âœˆï¸', 'ðŸ›«', 'ðŸ›¬', 'ðŸ›©ï¸', 'ðŸ’º', 'ðŸ›°ï¸', 'ðŸš€', 'ðŸ›¸',
              'ðŸš', 'ðŸ›¶', 'â›µ', 'ðŸš¤', 'ðŸ›¥ï¸', 'ðŸ›³ï¸', 'â›´ï¸', 'ðŸš¢', 'âš“', 'â›½',
              'ðŸš§', 'ðŸš¦', 'ðŸš¥', 'ðŸš', 'ðŸ—ºï¸', 'ðŸ—¿', 'ðŸ—½', 'ðŸ—¼', 'ðŸ°', 'ðŸ¯',
              'ðŸŸï¸', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸŽ ', 'â›²', 'â›±ï¸', 'ðŸ–ï¸', 'ðŸï¸', 'ðŸœï¸', 'ðŸŒ‹',
              'â›°ï¸', 'ðŸ”ï¸', 'ðŸ—»', 'ðŸ•ï¸', 'â›º', 'ðŸ ', 'ðŸ¡', 'ðŸ˜ï¸', 'ðŸšï¸', 'ðŸ—ï¸',
              'ðŸ­', 'ðŸ¢', 'ðŸ¬', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸª', 'ðŸ«',
              'ðŸ©', 'ðŸ’’', 'ðŸ›ï¸', 'â›ª', 'ðŸ•Œ', 'ðŸ•', 'ðŸ›•', 'ðŸ•‹', 'â›©ï¸', 'ðŸ›¤ï¸',
              'ðŸ›£ï¸', 'ðŸ—¾', 'ðŸŽ‘', 'ðŸžï¸', 'ðŸŒ…', 'ðŸŒ„', 'ðŸŒ ', 'ðŸŽ‡', 'ðŸŽ†', 'ðŸŒ‡',
              'ðŸŒ†', 'ðŸ™ï¸', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸŒ‰', 'ðŸŒ', 'âŒš', 'â°', 'â±ï¸', 'â²ï¸',

              // Japanese Culture
              'ðŸŽ‹', 'ðŸŽŒ', 'ðŸŽ', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ', 'ðŸŽ‘', 'ðŸŽ´', 'ðŸ€„', 'â›©ï¸',
              'ðŸ—¾', 'ðŸ—»', 'ðŸ¯', 'ðŸ®', 'ðŸŽ‹', 'ðŸŽŒ', 'ðŸŽ', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ',
              'ðŸŽ‘', 'ðŸ§§', 'ðŸ¥®', 'ðŸ¡', 'ðŸ¥', 'ðŸœ', 'ðŸ£', 'ðŸ±', 'ðŸ™', 'ðŸ˜',
              'ðŸš', 'ðŸ›', 'ðŸ¢', 'ðŸ ', 'ðŸ¥Ÿ', 'ðŸ¥¢', 'ðŸµ', 'ðŸ«–', 'ðŸ¶', 'ðŸŽ‹',
              'ðŸŽŒ', 'ðŸŽ', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ', 'ðŸŽ‘', 'ðŸŽ‹', 'ðŸŽŒ', 'ðŸŽ', 'ðŸŽŽ',
              'ðŸŽ', 'ðŸŽ', 'ðŸŽ‘', 'ðŸŽ‹', 'ðŸŽŒ', 'ðŸŽ', 'ðŸŽŽ', 'ðŸŽ', 'ðŸŽ', 'ðŸŽ‘',

              // Fantasy & Magic
              'ðŸ§™', 'ðŸ§™â€â™€ï¸', 'ðŸ§™â€â™‚ï¸', 'ðŸ§š', 'ðŸ§šâ€â™€ï¸', 'ðŸ§šâ€â™‚ï¸', 'ðŸ§›', 'ðŸ§›â€â™€ï¸', 'ðŸ§›â€â™‚ï¸', 'ðŸ§œ',
              'ðŸ§œâ€â™€ï¸', 'ðŸ§œâ€â™‚ï¸', 'ðŸ§', 'ðŸ§â€â™€ï¸', 'ðŸ§â€â™‚ï¸', 'ðŸ§ž', 'ðŸ§žâ€â™€ï¸', 'ðŸ§žâ€â™‚ï¸', 'ðŸ§Ÿ', 'ðŸ§Ÿâ€â™€ï¸',
              'ðŸ§Ÿâ€â™‚ï¸', 'ðŸ¦„', 'ðŸ‰', 'ðŸ²', 'ðŸ¦•', 'ðŸ¦–', 'ðŸ‘»', 'ðŸ’€', 'â˜ ï¸', 'ðŸ‘½',
              'ðŸ‘¾', 'ðŸ¤–', 'ðŸŽƒ', 'ðŸ˜º', 'ðŸ˜¸', 'ðŸ˜¹', 'ðŸ˜»', 'ðŸ˜¼', 'ðŸ˜½', 'ðŸ™€',
              'ðŸ˜¿', 'ðŸ˜¾', 'ðŸ§Œ', 'ðŸ§›', 'ðŸ§Ÿ', 'ðŸ§ž', 'ðŸ§œ', 'ðŸ§š', 'ðŸ§™', 'ðŸ§',

              // Activities & Sports
              'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±',
              'ðŸª€', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸªƒ', 'ðŸ¥…', 'â›³',
              'ðŸª', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¤¿', 'ðŸ¥Š', 'ðŸ¥‹', 'ðŸŽ½', 'ðŸ›¹', 'ðŸ›¼', 'ðŸ›·',
              'â›¸ï¸', 'ðŸ¥Œ', 'ðŸŽ¿', 'â›·ï¸', 'ðŸ‚', 'ðŸª‚', 'ðŸ‹ï¸', 'ðŸ‹ï¸â€â™€ï¸', 'ðŸ‹ï¸â€â™‚ï¸', 'ðŸ¤¼',
              'ðŸ¤¼â€â™€ï¸', 'ðŸ¤¼â€â™‚ï¸', 'ðŸ¤¸', 'ðŸ¤¸â€â™€ï¸', 'ðŸ¤¸â€â™‚ï¸', 'â›¹ï¸', 'â›¹ï¸â€â™€ï¸', 'â›¹ï¸â€â™‚ï¸', 'ðŸ¤º', 'ðŸ¤¾',
              'ðŸ¤¾â€â™€ï¸', 'ðŸ¤¾â€â™‚ï¸', 'ðŸŒï¸', 'ðŸŒï¸â€â™€ï¸', 'ðŸŒï¸â€â™‚ï¸', 'ðŸ‡', 'ðŸ§˜', 'ðŸ§˜â€â™€ï¸', 'ðŸ§˜â€â™‚ï¸', 'ðŸ„',
              'ðŸ„â€â™€ï¸', 'ðŸ„â€â™‚ï¸', 'ðŸŠ', 'ðŸŠâ€â™€ï¸', 'ðŸŠâ€â™‚ï¸', 'ðŸ¤½', 'ðŸ¤½â€â™€ï¸', 'ðŸ¤½â€â™‚ï¸', 'ðŸš£', 'ðŸš£â€â™€ï¸',
              'ðŸš£â€â™‚ï¸', 'ðŸ§—', 'ðŸ§—â€â™€ï¸', 'ðŸ§—â€â™‚ï¸', 'ðŸšµ', 'ðŸšµâ€â™€ï¸', 'ðŸšµâ€â™‚ï¸', 'ðŸš´', 'ðŸš´â€â™€ï¸', 'ðŸš´â€â™‚ï¸',
              'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ…', 'ðŸŽ–ï¸', 'ðŸµï¸', 'ðŸŽ—ï¸', 'ðŸŽ«', 'ðŸŽŸï¸',
              'ðŸŽª', 'ðŸ¤¹', 'ðŸ¤¹â€â™€ï¸', 'ðŸ¤¹â€â™‚ï¸', 'ðŸŽ­', 'ðŸ©°', 'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§',
              'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸª˜', 'ðŸŽ·', 'ðŸŽº', 'ðŸª—', 'ðŸŽ¸', 'ðŸª•', 'ðŸŽ»',

              // Faces & Expressions
              'ðŸ˜€', 'ðŸ˜ƒ', 'ðŸ˜„', 'ðŸ˜', 'ðŸ˜†', 'ðŸ˜…', 'ðŸ¤£', 'ðŸ˜‚', 'ðŸ™‚', 'ðŸ™ƒ',
              'ðŸ˜‰', 'ðŸ˜Š', 'ðŸ˜‡', 'ðŸ¥°', 'ðŸ˜', 'ðŸ¤©', 'ðŸ˜˜', 'ðŸ˜—', 'â˜ºï¸', 'ðŸ˜š',
              'ðŸ˜™', 'ðŸ¥²', 'ðŸ˜‹', 'ðŸ˜›', 'ðŸ˜œ', 'ðŸ¤ª', 'ðŸ˜', 'ðŸ¤‘', 'ðŸ¤—', 'ðŸ¤­',
              'ðŸ¤«', 'ðŸ¤”', 'ðŸ¤', 'ðŸ¤¨', 'ðŸ˜', 'ðŸ˜‘', 'ðŸ˜¶', 'ðŸ˜¶â€ðŸŒ«ï¸', 'ðŸ˜', 'ðŸ˜’',
              'ðŸ™„', 'ðŸ˜¬', 'ðŸ¤¥', 'ðŸ˜Œ', 'ðŸ˜”', 'ðŸ˜ª', 'ðŸ¤¤', 'ðŸ˜´', 'ðŸ˜·', 'ðŸ¤’',
              'ðŸ¤•', 'ðŸ¤¢', 'ðŸ¤®', 'ðŸ¤§', 'ðŸ¥µ', 'ðŸ¥¶', 'ðŸ¥´', 'ðŸ˜µ', 'ðŸ˜µâ€ðŸ’«', 'ðŸ¤¯',
              'ðŸ¤ ', 'ðŸ¥³', 'ðŸ¥¸', 'ðŸ˜Ž', 'ðŸ¤“', 'ðŸ§', 'ðŸ˜•', 'ðŸ˜Ÿ', 'ðŸ™', 'â˜¹ï¸',
              'ðŸ˜®', 'ðŸ˜¯', 'ðŸ˜²', 'ðŸ˜³', 'ðŸ¥º', 'ðŸ˜¦', 'ðŸ˜§', 'ðŸ˜¨', 'ðŸ˜°', 'ðŸ˜¥',
              'ðŸ˜¢', 'ðŸ˜­', 'ðŸ˜±', 'ðŸ˜–', 'ðŸ˜£', 'ðŸ˜ž', 'ðŸ˜“', 'ðŸ˜©', 'ðŸ˜«', 'ðŸ¥±',
              'ðŸ˜¤', 'ðŸ˜¡', 'ðŸ˜ ', 'ðŸ¤¬', 'ðŸ˜ˆ', 'ðŸ‘¿', 'ðŸ’€', 'â˜ ï¸', 'ðŸ’©', 'ðŸ¤¡',
              'ðŸ‘¹', 'ðŸ‘º', 'ðŸ‘»', 'ðŸ‘½', 'ðŸ‘¾', 'ðŸ¤–', 'ðŸŽƒ', 'ðŸ˜º', 'ðŸ˜¸', 'ðŸ˜¹',
              'ðŸ˜»', 'ðŸ˜¼', 'ðŸ˜½', 'ðŸ™€', 'ðŸ˜¿', 'ðŸ˜¾', 'ðŸ’‹', 'ðŸ’Œ', 'ðŸ’˜', 'ðŸ’',
              'ðŸ’–', 'ðŸ’—', 'ðŸ’“', 'ðŸ’ž', 'ðŸ’•', 'ðŸ’Ÿ', 'â£ï¸', 'ðŸ’”', 'â¤ï¸â€ðŸ”¥', 'â¤ï¸â€ðŸ©¹',

              // Hand Gestures
              'ðŸ‘‹', 'ðŸ¤š', 'ðŸ–ï¸', 'âœ‹', 'ðŸ––', 'ðŸ‘Œ', 'ðŸ¤Œ', 'ðŸ¤', 'âœŒï¸', 'ðŸ¤ž',
              'ðŸ«°', 'ðŸ¤Ÿ', 'ðŸ¤˜', 'ðŸ¤™', 'ðŸ‘ˆ', 'ðŸ‘‰', 'ðŸ‘†', 'ðŸ–•', 'ðŸ‘‡', 'â˜ï¸',
              'ðŸ‘', 'ðŸ‘Ž', 'âœŠ', 'ðŸ‘Š', 'ðŸ¤›', 'ðŸ¤œ', 'ðŸ‘', 'ðŸ™Œ', 'ðŸ«¶', 'ðŸ‘',
              'ðŸ¤²', 'ðŸ¤', 'ðŸ™', 'âœï¸', 'ðŸ’…', 'ðŸ¤³', 'ðŸ’ª', 'ðŸ¦¾', 'ðŸ¦µ', 'ðŸ¦¿',
              'ðŸ¦¶', 'ðŸ‘£', 'ðŸ‘‚', 'ðŸ¦»', 'ðŸ‘ƒ', 'ðŸ«€', 'ðŸ«', 'ðŸ§ ', 'ðŸ¦·', 'ðŸ¦´',
              'ðŸ‘€', 'ðŸ‘ï¸', 'ðŸ‘…', 'ðŸ‘„', 'ðŸ«¦', 'ðŸ’‹', 'ðŸ©¸', 'ðŸ¦¾', 'ðŸ¦¿', 'ðŸ’ª',

              // Time & Clocks
              'ðŸ•', 'ðŸ•‘', 'ðŸ•’', 'ðŸ•“', 'ðŸ•”', 'ðŸ••', 'ðŸ•–', 'ðŸ•—', 'ðŸ•˜', 'ðŸ•™',
              'ðŸ•š', 'ðŸ•›', 'ðŸ•œ', 'ðŸ•', 'ðŸ•ž', 'ðŸ•Ÿ', 'ðŸ• ', 'ðŸ•¡', 'ðŸ•¢', 'ðŸ•£',
              'ðŸ•¤', 'ðŸ•¥', 'ðŸ•¦', 'ðŸ•§', 'â°', 'â±ï¸', 'â²ï¸', 'ðŸ•°ï¸', 'âŒš', 'âŒ›',
              'â³', 'ðŸ“…', 'ðŸ“†', 'ðŸ—“ï¸', 'ðŸ“‡', 'ðŸ—ƒï¸', 'ðŸ—³ï¸', 'ðŸ—„ï¸', 'ðŸ“‹', 'ðŸ“',

              // Flags
              'ðŸ³ï¸', 'ðŸ´', 'ðŸ´â€â˜ ï¸', 'ðŸ³ï¸â€ðŸŒˆ', 'ðŸ³ï¸â€âš§ï¸', 'ðŸ‡ºðŸ‡³', 'ðŸ‡¦ðŸ‡º', 'ðŸ‡§ðŸ‡·', 'ðŸ‡¨ðŸ‡¦', 'ðŸ‡¨ðŸ‡³',
              'ðŸ‡©ðŸ‡ª', 'ðŸ‡ªðŸ‡¸', 'ðŸ‡«ðŸ‡·', 'ðŸ‡¬ðŸ‡§', 'ðŸ‡®ðŸ‡³', 'ðŸ‡®ðŸ‡¹', 'ðŸ‡¯ðŸ‡µ', 'ðŸ‡°ðŸ‡·', 'ðŸ‡²ðŸ‡½', 'ðŸ‡·ðŸ‡º',
              'ðŸ‡ºðŸ‡¸', 'ðŸ‡¿ðŸ‡¦', 'ðŸŽŒ', 'ðŸ', 'ðŸš©', 'ðŸŽ', 'ðŸš©', 'ðŸ´', 'ðŸ³ï¸', 'ðŸŽŒ',

              // Plants & Flowers
              'ðŸ’', 'ðŸŒ¸', 'ðŸ’®', 'ðŸµï¸', 'ðŸŒ¹', 'ðŸ¥€', 'ðŸŒº', 'ðŸŒ»', 'ðŸŒ¼', 'ðŸŒ·',
              'ðŸŒ±', 'ðŸª´', 'ðŸŒ²', 'ðŸŒ³', 'ðŸŒ´', 'ðŸŒµ', 'ðŸŒ¾', 'ðŸŒ¿', 'â˜˜ï¸', 'ðŸ€',
              'ðŸ', 'ðŸ‚', 'ðŸƒ', 'ðŸ„', 'ðŸŒ°', 'ðŸ¦€', 'ðŸ¦ž', 'ðŸ¦', 'ðŸ¦‘', 'ðŸ™',

              // Space & Science
              'ðŸ”­', 'ðŸ”¬', 'ðŸ§¬', 'ðŸ§ª', 'ðŸ§«', 'ðŸŒ¡ï¸', 'ðŸ§¹', 'ðŸ§º', 'ðŸ§»', 'ðŸš¿',
              'ðŸ›', 'ðŸ›€', 'ðŸ§¼', 'ðŸª¥', 'ðŸª’', 'ðŸ§½', 'ðŸª£', 'ðŸ§´', 'ðŸ›Žï¸', 'ðŸ”‘',
              'ðŸš€', 'ðŸ›¸', 'ðŸ›°ï¸', 'ðŸŒ', 'ðŸŒŽ', 'ðŸŒ', 'ðŸŒ•', 'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜',
              'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒ™', 'ðŸŒš', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ', 'â­',
              'ðŸŒŸ', 'âœ¨', 'ðŸ’«', 'â˜„ï¸', 'â˜€ï¸', 'ðŸŒ¤ï¸', 'â›…', 'ðŸŒ¥ï¸', 'â˜ï¸', 'ðŸŒ¦ï¸',
              'ðŸŒ§ï¸', 'â›ˆï¸', 'ðŸŒ©ï¸', 'âš¡', 'ðŸ”¥', 'ðŸ’¥', 'â„ï¸', 'ðŸŒ¨ï¸', 'â˜ƒï¸', 'â›„',
              'ðŸŒ¬ï¸', 'ðŸ’¨', 'ðŸŒªï¸', 'ðŸŒ«ï¸', 'ðŸŒˆ', 'â˜”', 'ðŸ’§', 'ðŸ’¦', 'ðŸŒŠ', 'ðŸŒ‹',

              // Music & Arts
              'ðŸŽµ', 'ðŸŽ¶', 'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸª˜', 'ðŸŽ·', 'ðŸŽº', 'ðŸª—', 'ðŸŽ¸',
              'ðŸª•', 'ðŸŽ»', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§', 'ðŸŽšï¸', 'ðŸŽ›ï¸', 'ðŸŽ™ï¸', 'ðŸ“»', 'ðŸŽžï¸',
              'ðŸ“½ï¸', 'ðŸŽ¥', 'ðŸ“º', 'ðŸ“·', 'ðŸ“¸', 'ðŸ“¹', 'ðŸ“¼', 'ðŸ”', 'ðŸ”Ž', 'ðŸ•¯ï¸',
              'ðŸ’¡', 'ðŸ”¦', 'ðŸ®', 'ðŸª”', 'ðŸŽ¨', 'ðŸ–Œï¸', 'ðŸ–ï¸', 'ðŸ§µ', 'ðŸª¡', 'ðŸ§¶',
              'ðŸª¢', 'ðŸ–¼ï¸', 'ðŸŽ­', 'ðŸŽª', 'ðŸ¤¹', 'ðŸŽ ', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸŽ£', 'ðŸŽ¿',

              // Books & Learning
              'ðŸ“š', 'ðŸ“–', 'ðŸ““', 'ðŸ“”', 'ðŸ“’', 'ðŸ“•', 'ðŸ“—', 'ðŸ“˜', 'ðŸ“™', 'ðŸ“‘',
              'ðŸ“ƒ', 'ðŸ“œ', 'ðŸ“„', 'ðŸ“°', 'ðŸ—žï¸', 'ðŸ”–', 'ðŸ·ï¸', 'ðŸ’°', 'ðŸª™', 'ðŸ’´',
              'ðŸ“', 'âœï¸', 'âœ’ï¸', 'ðŸ–‹ï¸', 'ðŸ–Šï¸', 'ðŸ–Œï¸', 'ðŸ–ï¸', 'ðŸ’¼', 'ðŸ“', 'ðŸ“‚',
              'ðŸ—‚ï¸', 'ðŸ“…', 'ðŸ“†', 'ðŸ—’ï¸', 'ðŸ—“ï¸', 'ðŸ“‡', 'ðŸ“ˆ', 'ðŸ“‰', 'ðŸ“Š', 'ðŸ“‹',
              'ðŸ“Œ', 'ðŸ“', 'ðŸ“Ž', 'ðŸ–‡ï¸', 'âœ‚ï¸', 'ðŸ—ƒï¸', 'ðŸ—„ï¸', 'ðŸ—‘ï¸', 'ðŸ”’', 'ðŸ”“',

              // Tech & Computers
              'ðŸ’»', 'ðŸ–¥ï¸', 'ðŸ–¨ï¸', 'âŒ¨ï¸', 'ðŸ–±ï¸', 'ðŸ–²ï¸', 'ðŸ’½', 'ðŸ’¾', 'ðŸ’¿', 'ðŸ“€',
              'ðŸ“±', 'ðŸ“²', 'â˜Žï¸', 'ðŸ“ž', 'ðŸ“Ÿ', 'ðŸ“ ', 'ðŸ”‹', 'ðŸ”Œ', 'ðŸ“¡', 'â°',
              'â±ï¸', 'â²ï¸', 'ðŸ•°ï¸', 'âŒš', 'ðŸ””', 'ðŸ”•', 'ðŸ“¢', 'ðŸ“£', 'ðŸ”Š', 'ðŸ”‰',
              'ðŸ”ˆ', 'ðŸ”‡', 'ðŸ“¯', 'ðŸ””', 'ðŸŽ™ï¸', 'ðŸŽšï¸', 'ðŸŽ›ï¸', 'ðŸ“»', 'ðŸ“º', 'ðŸ“»',

              // Gaming & Fun
              'ðŸŽ®', 'ðŸŽ°', 'ðŸŽ²', 'ðŸŽ¯', 'ðŸŽ³', 'ðŸŽª', 'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§',
              'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸŽ·', 'ðŸŽº', 'ðŸŽ¸', 'ðŸŽ»', 'ðŸŽ²', 'â™Ÿï¸', 'ðŸŽ¯',
              'ðŸŽ³', 'ðŸŽ®', 'ðŸŽ°', 'ðŸ§©', 'ðŸ§¸', 'ðŸª€', 'ðŸª', 'ðŸŽ ', 'ðŸŽ¡', 'ðŸŽ¢',
              'ðŸŽ£', 'ðŸŽ¿', 'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰', 'ðŸ…', 'ðŸŽ–ï¸', 'ðŸµï¸', 'ðŸŽ—ï¸',

              // Celestial & Mystical
              'â˜€ï¸', 'ðŸŒ™', 'â­', 'âœ¨', 'ðŸ’«', 'ðŸŒŸ', 'â˜„ï¸', 'ðŸŒ ', 'ðŸŒŒ', 'ðŸŒ•',
              'ðŸŒ–', 'ðŸŒ—', 'ðŸŒ˜', 'ðŸŒ‘', 'ðŸŒ’', 'ðŸŒ“', 'ðŸŒ”', 'ðŸŒš', 'ðŸŒ', 'ðŸŒ›',
              'ðŸŒœ', 'ðŸŒž', 'ðŸª', 'ðŸŒ', 'ðŸŒŽ', 'ðŸŒ', 'ðŸ’«', 'âœ¨', 'â­', 'ðŸŒŸ',

              // Household & Daily
              'ðŸ ', 'ðŸ¡', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸ©', 'ðŸª',
              'ðŸ«', 'ðŸ¬', 'ðŸ­', 'ðŸ¯', 'ðŸ°', 'ðŸ’’', 'ðŸ—¼', 'ðŸ—½', 'â›ª', 'ðŸ•Œ',
              'ðŸ•', 'ðŸ›•', 'ðŸ•‹', 'â›©ï¸', 'ðŸ›¤ï¸', 'ðŸ›£ï¸', 'ðŸ—¾', 'ðŸŽ‘', 'ðŸžï¸', 'ðŸŒ…',
              'ðŸŒ„', 'ðŸŒ ', 'ðŸŽ‡', 'ðŸŽ†', 'ðŸŒ‡', 'ðŸŒ†', 'ðŸ™ï¸', 'ðŸŒƒ', 'ðŸŒŒ', 'ðŸŒ‰',

              // Food Categories
              'ðŸŽ', 'ðŸ', 'ðŸŠ', 'ðŸ‹', 'ðŸŒ', 'ðŸ‰', 'ðŸ‡', 'ðŸ“', 'ðŸ«', 'ðŸˆ',
              'ðŸ’', 'ðŸ‘', 'ðŸ', 'ðŸ¥', 'ðŸ¥­', 'ðŸ†', 'ðŸ¥‘', 'ðŸ¥¦', 'ðŸ¥¬', 'ðŸ¥’',
              'ðŸŒ¶ï¸', 'ðŸ«‘', 'ðŸŒ½', 'ðŸ¥•', 'ðŸ«’', 'ðŸ§„', 'ðŸ§…', 'ðŸ¥”', 'ðŸ ', 'ðŸ«˜',
              'ðŸ¥', 'ðŸ¥¯', 'ðŸž', 'ðŸ¥–', 'ðŸ¥¨', 'ðŸ§€', 'ðŸ¥š', 'ðŸ³', 'ðŸ§ˆ', 'ðŸ¥ž',

              // Drinks
              'ðŸ§ƒ', 'ðŸ¥¤', 'ðŸ§‹', 'ðŸ¶', 'ðŸº', 'ðŸ»', 'ðŸ¥‚', 'ðŸ·', 'ðŸ¥ƒ', 'ðŸ¸',
              'ðŸ¹', 'ðŸ§‰', 'ðŸ¾', 'ðŸ¥„', 'ðŸ´', 'ðŸ½ï¸', 'ðŸ¥£', 'ðŸ¥¡', 'ðŸ¥¢', 'ðŸ§‚',
              'â˜•', 'ðŸ«–', 'ðŸµ', 'ðŸ§ƒ', 'ðŸ¥¤', 'ðŸ§‹', 'ðŸ¶', 'ðŸ¼', 'ðŸ¥›', 'ðŸ«—',

              // Desserts
              'ðŸ¦', 'ðŸ§', 'ðŸ¨', 'ðŸ©', 'ðŸª', 'ðŸŽ‚', 'ðŸ°', 'ðŸ§', 'ðŸ¥§', 'ðŸ«',
              'ðŸ¬', 'ðŸ­', 'ðŸ®', 'ðŸ¯', 'ðŸ¡', 'ðŸ¥', 'ðŸ˜', 'ðŸ™', 'ðŸš', 'ðŸ›',

              // Asian Cuisine
              'ðŸœ', 'ðŸ', 'ðŸ ', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¡', 'ðŸ˜', 'ðŸ™',
              'ðŸš', 'ðŸ›', 'ðŸœ', 'ðŸ', 'ðŸ ', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¡',
              'ðŸ±', 'ðŸ²', 'ðŸ³', 'ðŸ´', 'ðŸµ', 'ðŸ¶', 'ðŸ·', 'ðŸ¸', 'ðŸ¹', 'ðŸº',

              // More Nature
              'ðŸŒµ', 'ðŸŽ„', 'ðŸŒ²', 'ðŸŒ³', 'ðŸŒ´', 'ðŸŒ±', 'ðŸŒ¿', 'â˜˜ï¸', 'ðŸ€', 'ðŸŽ',
              'ðŸª´', 'ðŸŽ‹', 'ðŸƒ', 'ðŸ‚', 'ðŸ', 'ðŸ„', 'ðŸŒ¾', 'ðŸ’', 'ðŸŒ·', 'ðŸŒ¹',
              'ðŸ¥€', 'ðŸŒº', 'ðŸŒ¸', 'ðŸŒ¼', 'ðŸŒ»', 'ðŸŒž', 'ðŸŒ', 'ðŸŒ›', 'ðŸŒœ', 'ðŸŒš',

              // Weather Variations
              'â˜€ï¸', 'ðŸŒ¤ï¸', 'â›…', 'ðŸŒ¥ï¸', 'â˜ï¸', 'ðŸŒ¦ï¸', 'ðŸŒ§ï¸', 'â›ˆï¸', 'ðŸŒ©ï¸', 'âš¡',
              'ðŸ”¥', 'ðŸ’¥', 'â„ï¸', 'ðŸŒ¨ï¸', 'â˜ƒï¸', 'â›„', 'ðŸŒ¬ï¸', 'ðŸ’¨', 'ðŸŒªï¸', 'ðŸŒ«ï¸',
              'ðŸŒˆ', 'â˜”', 'ðŸ’§', 'ðŸ’¦', 'ðŸŒŠ', 'ðŸŒ‹', 'ðŸŒŒ', 'ðŸŒ ', 'â­', 'ðŸŒŸ',

              // Fantasy Creatures
              'ðŸ§™', 'ðŸ§š', 'ðŸ§›', 'ðŸ§œ', 'ðŸ§', 'ðŸ§ž', 'ðŸ§Ÿ', 'ðŸ¦„', 'ðŸ‰', 'ðŸ²',
              'ðŸ¦•', 'ðŸ¦–', 'ðŸ‘»', 'ðŸ’€', 'â˜ ï¸', 'ðŸ‘½', 'ðŸ‘¾', 'ðŸ¤–', 'ðŸŽƒ', 'ðŸ§Œ',
              'ðŸ§›', 'ðŸ§Ÿ', 'ðŸ§ž', 'ðŸ§œ', 'ðŸ§š', 'ðŸ§™', 'ðŸ§', 'ðŸ¦„', 'ðŸ‰', 'ðŸ²',

              // Sports Equipment
              'âš½', 'ðŸ€', 'ðŸˆ', 'âš¾', 'ðŸ¥Ž', 'ðŸŽ¾', 'ðŸ', 'ðŸ‰', 'ðŸ¥', 'ðŸŽ±',
              'ðŸª€', 'ðŸ“', 'ðŸ¸', 'ðŸ’', 'ðŸ‘', 'ðŸ¥', 'ðŸ', 'ðŸªƒ', 'ðŸ¥…', 'â›³',
              'ðŸª', 'ðŸ¹', 'ðŸŽ£', 'ðŸ¤¿', 'ðŸ¥Š', 'ðŸ¥‹', 'ðŸŽ½', 'ðŸ›¹', 'ðŸ›¼', 'ðŸ›·',

              // Musical Notes
              'ðŸŽµ', 'ðŸŽ¶', 'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸª˜', 'ðŸŽ·', 'ðŸŽº', 'ðŸª—', 'ðŸŽ¸',
              'ðŸª•', 'ðŸŽ»', 'ðŸŽ™ï¸', 'ðŸŽšï¸', 'ðŸŽ›ï¸', 'ðŸ“»', 'ðŸŽ§', 'ðŸŽ¤', 'ðŸ“¯', 'ðŸŽ¬',

              // Building Types
              'ðŸ ', 'ðŸ¡', 'ðŸ¢', 'ðŸ£', 'ðŸ¤', 'ðŸ¥', 'ðŸ¦', 'ðŸ¨', 'ðŸ©', 'ðŸª',
              'ðŸ«', 'ðŸ¬', 'ðŸ­', 'ðŸ¯', 'ðŸ°', 'ðŸ’’', 'ðŸ—¼', 'ðŸ—½', 'â›ª', 'ðŸ•Œ',
              'ðŸ•', 'ðŸ›•', 'ðŸ•‹', 'â›©ï¸', 'ðŸ›¤ï¸', 'ðŸ›£ï¸', 'ðŸ—¾', 'ðŸŽ‘', 'ðŸžï¸', 'ðŸŒ…',

              // Transportation Modes
              'ðŸš—', 'ðŸš•', 'ðŸš™', 'ðŸšŒ', 'ðŸšŽ', 'ðŸŽï¸', 'ðŸš“', 'ðŸš‘', 'ðŸš’', 'ðŸš',
              'ðŸ›»', 'ðŸšš', 'ðŸš›', 'ðŸšœ', 'ðŸ¦¯', 'ðŸ¦½', 'ðŸ¦¼', 'ðŸ›´', 'ðŸš²', 'ðŸ›µ',
              'ðŸï¸', 'ðŸ›º', 'ðŸš¨', 'ðŸš”', 'ðŸš', 'ðŸš˜', 'ðŸš–', 'ðŸš¡', 'ðŸš ', 'ðŸšŸ',

              // More Fun Emojis
              'ðŸŽŠ', 'ðŸŽ‰', 'ðŸŽ', 'ðŸŽˆ', 'ðŸŽ€', 'ðŸŽ„', 'ðŸŽƒ', 'ðŸŽ…', 'ðŸ¤¶', 'ðŸ§‘â€ðŸŽ„',
              'ðŸ¦Œ', 'ðŸ§', 'ðŸ§™', 'ðŸ§š', 'ðŸ§›', 'ðŸ§œ', 'ðŸ§', 'ðŸ§ž', 'ðŸ§Ÿ', 'ðŸŽ­',
              'ðŸŽª', 'ðŸŽ¨', 'ðŸŽ¬', 'ðŸŽ¤', 'ðŸŽ§', 'ðŸŽ¼', 'ðŸŽ¹', 'ðŸ¥', 'ðŸŽ·', 'ðŸŽº',
              'ðŸŽ¸', 'ðŸŽ»', 'ðŸŽ²', 'ðŸŽ¯', 'ðŸŽ³', 'ðŸŽ®', 'ðŸŽ°', 'ðŸ§©', 'ðŸ§¸', 'ðŸª€',
              'ðŸª', 'ðŸŽ ', 'ðŸŽ¡', 'ðŸŽ¢', 'ðŸŽ£', 'ðŸŽ¿', 'ðŸ†', 'ðŸ¥‡', 'ðŸ¥ˆ', 'ðŸ¥‰',
              'ðŸ…', 'ðŸŽ–ï¸', 'ðŸµï¸', 'ðŸŽ—ï¸', 'ðŸŽ«', 'ðŸŽŸï¸', 'ðŸŽª', 'ðŸ¤¹', 'ðŸŽ­', 'ðŸ©°'
            ];

            function pickEmoji() {
              return emojiBank[Math.floor(Math.random() * emojiBank.length)];
            }

            const statePath = 'data/community-backlog/automation-state.json';
            const themeBacklogPath = 'data/community-backlog/theme-backlog.json';
            const factsBacklogPath = 'data/community-backlog/facts-backlog.json';
            const proverbsBacklogPath = 'data/community-backlog/proverbs-backlog.json';
            const triviaBacklogPath = 'data/community-backlog/trivia-backlog.json';
            const grammarBacklogPath = 'data/community-backlog/grammar-backlog.json';
            const animeQuotesBacklogPath = 'data/community-backlog/anime-quotes-backlog.json';

            const themesSourcePath = 'data/community-content/community-themes.json';
            const factsSourcePath = 'data/community-content/japan-facts.json';
            const proverbsSourcePath = 'data/community-content/japanese-proverbs.json';
            const triviaSourcePaths = {
              easy: 'data/community-content/japan-trivia-easy.json',
              medium: 'data/community-content/japan-trivia-medium.json',
              hard: 'data/community-content/japan-trivia-hard.json'
            };
            const triviaLegacyPath = 'data/community-content/japan-trivia.json';
            const grammarSourcePath = 'data/community-content/japanese-grammar.json';
            const animeQuotesSourcePath = 'data/community-content/anime-quotes.json';

            let state = JSON.parse(fs.readFileSync(statePath, 'utf8'));
            const themes = JSON.parse(fs.readFileSync(themeBacklogPath, 'utf8'));
            const facts = JSON.parse(fs.readFileSync(factsBacklogPath, 'utf8'));
            const proverbs = JSON.parse(fs.readFileSync(proverbsBacklogPath, 'utf8'));
            const trivia = JSON.parse(fs.readFileSync(triviaBacklogPath, 'utf8'));
            const grammar = JSON.parse(fs.readFileSync(grammarBacklogPath, 'utf8'));
            const animeQuotes = JSON.parse(fs.readFileSync(animeQuotesBacklogPath, 'utf8'));

            if (typeof state.consecutiveNoIssueRuns !== 'number') {
              state.consecutiveNoIssueRuns = 0;
            }

            let backlogChanged = false;

            let existingFacts = [];
            if (fs.existsSync(factsSourcePath)) {
              try {
                existingFacts = JSON.parse(fs.readFileSync(factsSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${factsSourcePath}: ${e.message}`);
              }
            }

            let existingProverbs = [];
            if (fs.existsSync(proverbsSourcePath)) {
              try {
                existingProverbs = JSON.parse(fs.readFileSync(proverbsSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${proverbsSourcePath}: ${e.message}`);
              }
            }

            let existingTrivia = [];
            const triviaSourceFiles = [
              ...Object.values(triviaSourcePaths),
              triviaLegacyPath
            ];
            triviaSourceFiles.forEach(function(path) {
              if (fs.existsSync(path)) {
                try {
                  const data = JSON.parse(fs.readFileSync(path, 'utf8'));
                  if (Array.isArray(data)) {
                    existingTrivia = existingTrivia.concat(data);
                  }
                } catch (e) {
                  console.log(`Could not parse ${path}: ${e.message}`);
                }
              }
            });

            let existingGrammar = [];
            if (fs.existsSync(grammarSourcePath)) {
              try {
                existingGrammar = JSON.parse(fs.readFileSync(grammarSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${grammarSourcePath}: ${e.message}`);
              }
            }

            let existingAnimeQuotes = [];
            if (fs.existsSync(animeQuotesSourcePath)) {
              try {
                existingAnimeQuotes = JSON.parse(fs.readFileSync(animeQuotesSourcePath, 'utf8'));
              } catch (e) {
                console.log(`Could not parse ${animeQuotesSourcePath}: ${e.message}`);
              }
            }

            let themesSourceContent = '';
            let existingThemes = [];
            if (fs.existsSync(themesSourcePath)) {
              try {
                themesSourceContent = fs.readFileSync(themesSourcePath, 'utf8');
                const parsedThemes = JSON.parse(themesSourceContent);
                if (Array.isArray(parsedThemes)) {
                  existingThemes = parsedThemes;
                }
              } catch (e) {
                console.log(`Could not read ${themesSourcePath}: ${e.message}`);
              }
            }

            async function hasOpenIssueForQuery(query) {
              const q = `${query} repo:${context.repo.owner}/${context.repo.repo} is:issue is:open label:${templates.labels.community}`;
              try {
                const res = await github.rest.search.issuesAndPullRequests({
                  q: q,
                  per_page: 1
                });
                return res.data && res.data.total_count > 0;
              } catch (e) {
                console.log(`Search query failed: ${q} :: ${e.message}`);
                return false;
              }
            }

            const defaultOrder = ['theme', 'fact', 'proverb', 'trivia', 'grammar', 'animeQuote'];
            const typeOrder = forceType && defaultOrder.includes(forceType)
              ? [forceType]
              : defaultOrder;
            const currentIndex = typeOrder.indexOf(state.lastType);

            let item, issueTitle, issueBody;
            let selectedType = null;

            for (let offset = 1; offset <= typeOrder.length; offset += 1) {
              const nextType = typeOrder[((currentIndex === -1 ? -1 : currentIndex) + offset) % typeOrder.length];
              item = null;
              issueTitle = null;
              issueBody = null;

              if (nextType === 'theme') {
              // Skip items that are already issued OR completed OR already exist in main
              item = themes.find(function(th) {
                if (th.issued || th.completed) {
                  return false;
                }
                if (themesSourceContent) {
                  const hasId = th.id && existingThemes.some(function(theme) { return theme.id === th.id; });
                  const hasName = th.name && existingThemes.some(function(theme) {
                    return (theme.name || '').toLowerCase() === th.name.toLowerCase();
                  });
                  if (hasId || hasName) {
                    const themeIdx = themes.findIndex(function(ti) { return ti.id === th.id; });
                    themes[themeIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });
              
              if (!item) {
                console.log('No more themes available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                }
                continue;
              }
              
              // Check for duplicate theme issue
              const duplicateTheme = await hasOpenIssueForQuery(`"Add New Color Theme:" "${item.name}"`);
              
              if (duplicateTheme) {
                console.log(`Issue already exists for theme "${item.name}": Marking as issued and skipping.`);
                const themeIdx = themes.findIndex(function(th) { return th.id === item.id; });
                themes[themeIdx].issued = true;
                fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.theme;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{name}', item.name);
              
              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle, { step2: tmpl.step2, step3: tmpl.step3 }).map((instr, i) => `${i + 1}. ${instr.replace(/{name}/g, item.name)}`);
              
              const codeBlock = `\`\`\`typescript\n{\n  id: '${item.id}',\n  backgroundColor: '${item.backgroundColor}',\n  mainColor: '${item.mainColor}',\n  secondaryColor: '${item.secondaryColor}'\n},\n\`\`\``;
              
              issueBody = `${tmpl.header.replace('{name}', item.name)}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.detailsHeader}\n\n| Property | Value |\n|----------|-------|\n| **ID** | \`${item.id}\` |\n| **Background** | \`${item.backgroundColor}\` |\n| **Main Color** | \`${item.mainColor}\` |\n| **Secondary** | \`${item.secondaryColor}\` |\n\n> ${tmpl.vibeLabel} ${item.description}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n${instructions[6]}\n\n---\n\n${common.footer}`;
              
              const themeIndex = themes.findIndex(function(th) { return th.id === item.id; });
              themes[themeIndex].issued = true;
              fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
              backlogChanged = true;
              
              } else if (nextType === 'fact') {
              // Skip items that are already issued OR completed OR already exist in main
              item = facts.find(function(f) {
                if (f.issued || f.completed) {
                  return false;
                }
                if (Array.isArray(existingFacts) && existingFacts.includes(f.fact)) {
                  const factIdx = facts.findIndex(function(fi) { return fi.id === f.id; });
                  facts[factIdx].completed = true;
                  backlogChanged = true;
                  return false;
                }
                return true;
              });
              
              if (!item) {
                console.log('No more facts available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                }
                continue;
              }
              
              // Check for duplicate fact issue
              const duplicateFact = await hasOpenIssueForQuery(`"Add Japan Fact #${item.id}"`);
              
              if (duplicateFact) {
                console.log(`Issue already exists for fact #${item.id}: Marking as issued and skipping.`);
                const factIdx = facts.findIndex(function(f) { return f.id === item.id; });
                facts[factIdx].issued = true;
                fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.fact;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);
              
              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              
              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.factHeader}\n\n> ${item.fact}\n\n${common.instructionsHeader}\n\n${instructions.join('\n')}\n\n---\n\n${common.footer}`;
              
              const factIndex = facts.findIndex(function(f) { return f.id === item.id; });
              facts[factIndex].issued = true;
              fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
              backlogChanged = true;
              } else if (nextType === 'proverb') {
              // Proverb
              item = proverbs.find(function(p) {
                if (p.issued || p.completed) {
                  return false;
                }
                if (Array.isArray(existingProverbs)) {
                  const exists = existingProverbs.some(function(ep) {
                    if (!ep || typeof ep !== 'object') {
                      return false;
                    }
                    return ep.japanese === p.japanese && ep.romaji === p.romaji && ep.english === p.english;
                  });
                  if (exists) {
                    const proverbIdx = proverbs.findIndex(function(pi) { return pi.id === p.id; });
                    proverbs[proverbIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });
              
              if (!item) {
                console.log('No more proverbs available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                }
                continue;
              }
              
              // Check for duplicate proverb issue
              const duplicateProverb = await hasOpenIssueForQuery(`"Add Japanese Proverb #${item.id}"`);
              
              if (duplicateProverb) {
                console.log(`Issue already exists for proverb #${item.id}: Marking as issued and skipping.`);
                const proverbIdx = proverbs.findIndex(function(p) { return p.id === item.id; });
                proverbs[proverbIdx].issued = true;
                fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                backlogChanged = true;

                continue;
              }
              
              const tmpl = t.proverb;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);
              
              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              
              const codeBlock = `\`\`\`json\n{\n  "japanese": "${item.japanese}",\n  "romaji": "${item.romaji}",\n  "english": "${item.english}",\n  "meaning": "${item.meaning}"\n}\n\`\`\``;
              
              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.proverbHeader}\n\n| Japanese | Reading | English |\n|----------|---------|---------|\n| **${item.japanese}** | ${item.romaji} | ${item.english} |\n\n> ðŸ’¡ **Meaning:** ${item.meaning}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n${instructions[6]}\n\n---\n\n${common.footer}`;
              
              const proverbIndex = proverbs.findIndex(function(p) { return p.id === item.id; });
              proverbs[proverbIndex].issued = true;
              fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
              backlogChanged = true;
              } else if (nextType === 'trivia') {
              item = trivia.find(function(q) {
                if (q.issued || q.completed) {
                  return false;
                }
                if (Array.isArray(existingTrivia)) {
                  const exists = existingTrivia.some(function(eq) {
                    if (!eq || typeof eq !== 'object') {
                      return false;
                    }
                    if (eq.question !== q.question) {
                      return false;
                    }
                    const eqAnswers = Array.isArray(eq.answers) ? eq.answers : [];
                    const qAnswers = Array.isArray(q.answers) ? q.answers : [];
                    return eqAnswers.length === qAnswers.length && eqAnswers.every(function(ans, idx) {
                      return ans === qAnswers[idx];
                    });
                  });
                  if (exists) {
                    const triviaIdx = trivia.findIndex(function(ti) { return ti.id === q.id; });
                    trivia[triviaIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });

              if (!item) {
                console.log('No more trivia questions available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                  fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                  fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                }
                continue;
              }

              const duplicateTrivia = await hasOpenIssueForQuery(`"Add New Trivia Question #${item.id}"`);

              if (duplicateTrivia) {
                console.log(`Issue already exists for trivia #${item.id}: Marking as issued and skipping.`);
                const triviaIdx = trivia.findIndex(function(q) { return q.id === item.id; });
                trivia[triviaIdx].issued = true;
                fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                backlogChanged = true;
                continue;
              }

              const tmpl = t.trivia;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);

              const difficultyFile = triviaSourcePaths[item.difficulty] || triviaSourcePaths.easy;
              const instructions = t.buildInstructions(tmpl.file.replace('{difficultyFile}', difficultyFile), tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              const answers = Array.isArray(item.answers) ? item.answers : [];
              const codeBlock = `\`\`\`json\n{\n  "question": "${item.question}",\n  "difficulty": "${item.difficulty}",\n  "answers": [\n    "${answers.join('\",\n    \"')}"\n  ],\n  "correctIndex": ${item.correctIndex}\n}\n\`\`\``;

              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.triviaHeader}\n\n**Question:** ${item.question}\n\n**Answers:**\n${answers.map(function(a, idx) { return `${idx + 1}. ${a}`; }).join('\n')}\n\n**Correct Answer Index:** ${item.correctIndex}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n${instructions[6]}\n\n---\n\n${common.footer}`;

              const triviaIndex = trivia.findIndex(function(q) { return q.id === item.id; });
              trivia[triviaIndex].issued = true;
              fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
              backlogChanged = true;
              } else if (nextType === 'grammar') {
              // Grammar
              item = grammar.find(function(g) {
                if (g.issued || g.completed) {
                  return false;
                }
                if (Array.isArray(existingGrammar) && existingGrammar.includes(g.text)) {
                  const grammarIdx = grammar.findIndex(function(gi) { return gi.id === g.id; });
                  grammar[grammarIdx].completed = true;
                  backlogChanged = true;
                  return false;
                }
                return true;
              });

              if (!item) {
                console.log('No more grammar points available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                  fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                  fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                }
                continue;
              }

              const duplicateGrammar = await hasOpenIssueForQuery(`"Add New Grammar Point #${item.id}"`);

              if (duplicateGrammar) {
                console.log(`Issue already exists for grammar #${item.id}: Marking as issued and skipping.`);
                const grammarIdx = grammar.findIndex(function(g) { return g.id === item.id; });
                grammar[grammarIdx].issued = true;
                fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                backlogChanged = true;
                continue;
              }

              const tmpl = t.grammar;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);

              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              const codeBlock = `\`\`\`json\n"${item.text}"\n\`\`\``;

              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.grammarHeader}\n\n> ${item.text}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n${instructions[6]}\n\n---\n\n${common.footer}`;

              const grammarIndex = grammar.findIndex(function(g) { return g.id === item.id; });
              grammar[grammarIndex].issued = true;
              fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
              backlogChanged = true;
              } else {
              // Anime Quote
              item = animeQuotes.find(function(q) {
                if (q.issued || q.completed) {
                  return false;
                }
                if (Array.isArray(existingAnimeQuotes)) {
                  const exists = existingAnimeQuotes.some(function(eq) {
                    if (!eq || typeof eq !== 'object') {
                      return false;
                    }
                    return eq.japanese === q.japanese
                      && eq.romaji === q.romaji
                      && eq.english === q.english
                      && eq.anime === q.anime
                      && eq.character === q.character;
                  });
                  if (exists) {
                    const quoteIdx = animeQuotes.findIndex(function(qi) { return qi.id === q.id; });
                    animeQuotes[quoteIdx].completed = true;
                    backlogChanged = true;
                    return false;
                  }
                }
                return true;
              });

              if (!item) {
                console.log('No more anime quotes available in backlog.');
                if (backlogChanged) {
                  fs.writeFileSync(themeBacklogPath, JSON.stringify(themes, null, 2));
                  fs.writeFileSync(factsBacklogPath, JSON.stringify(facts, null, 2));
                  fs.writeFileSync(proverbsBacklogPath, JSON.stringify(proverbs, null, 2));
                  fs.writeFileSync(triviaBacklogPath, JSON.stringify(trivia, null, 2));
                  fs.writeFileSync(grammarBacklogPath, JSON.stringify(grammar, null, 2));
                  fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
                }
                continue;
              }

              const duplicateQuote = await hasOpenIssueForQuery(`"Add Famous Anime Quote #${item.id}"`);

              if (duplicateQuote) {
                console.log(`Issue already exists for anime quote #${item.id}: Marking as issued and skipping.`);
                const quoteIdx = animeQuotes.findIndex(function(q) { return q.id === item.id; });
                animeQuotes[quoteIdx].issued = true;
                fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
                backlogChanged = true;
                continue;
              }

              const tmpl = t.animeQuote;
              const common = t.common;
              issueTitle = tmpl.title
                .replace('{emoji}', pickEmoji())
                .replace('{id}', item.id);

              const instructions = t.buildInstructions(tmpl.file, tmpl.itemType, tmpl.prTitle).map((instr, i) => `${i + 1}. ${instr.replace(/{id}/g, item.id)}`);
              const codeBlock = `\`\`\`json\n{\n  \"japanese\": \"${item.japanese}\",\n  \"romaji\": \"${item.romaji}\",\n  \"english\": \"${item.english}\",\n  \"anime\": \"${item.anime}\",\n  \"character\": \"${item.character}\"\n}\n\`\`\``;

              issueBody = `${tmpl.header}\n\n**Category:** ${tmpl.category}  \n**Difficulty:** ${common.difficulty}  \n**Estimated Time:** ${tmpl.estimatedTime}\n\n---\n\n### ðŸŽ¯ Your Task\n\n${tmpl.taskDescription}\n\n${tmpl.quoteHeader}\n\n| Japanese | Romaji | English |\n|----------|--------|---------|\n| **${item.japanese}** | ${item.romaji} | ${item.english} |\n\n**Anime:** ${item.anime}  \n**Character:** ${item.character}\n\n${common.instructionsHeader}\n\n${instructions[0]}\n${instructions[1]}\n${instructions[2]}\n\n${codeBlock}\n\n${instructions[3]}\n${instructions[4]}\n${instructions[5]}\n${instructions[6]}\n\n---\n\n${common.footer}`;

              const quoteIndex = animeQuotes.findIndex(function(q) { return q.id === item.id; });
              animeQuotes[quoteIndex].issued = true;
              fs.writeFileSync(animeQuotesBacklogPath, JSON.stringify(animeQuotes, null, 2));
              backlogChanged = true;
            }

              if (issueTitle && issueBody && item) {
                selectedType = nextType;
                break;
              }
            }

            if (!selectedType) {
              console.log('No available items found across theme/fact/proverb backlogs.');
              state.lastRun = new Date().toISOString();
              state.consecutiveNoIssueRuns = (state.consecutiveNoIssueRuns || 0) + 1;
              fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

              core.setOutput('issue_created', 'false');
              core.setOutput('reason', 'no_available_items');
              core.setOutput('consecutive_no_issue_runs', String(state.consecutiveNoIssueRuns));
              core.setOutput('should_commit', backlogChanged ? 'true' : 'false');
              core.setOutput('notify_discord', state.consecutiveNoIssueRuns >= 8 ? 'true' : 'false');
              return;
            }

            if (dryRun) {
              console.log(`Dry run enabled; would create a ${selectedType} issue: ${issueTitle}`);

              state.lastType = selectedType;
              state.lastRun = new Date().toISOString();
              state.consecutiveNoIssueRuns = 0;
              fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

              core.setOutput('issue_created', 'false');
              core.setOutput('reason', 'dry_run');
              core.setOutput('selected_type', selectedType);
              core.setOutput('should_commit', backlogChanged ? 'true' : 'false');
              core.setOutput('notify_discord', 'false');
              return;
            }

            const labels = templates.labels.newIssue;

            const response = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: issueTitle,
              body: issueBody,
              labels: labels,
              type: 'Task'
            });

            console.log(`Created issue #${response.data.number}: ${issueTitle}`);

            state.lastType = selectedType;
            state.lastRun = new Date().toISOString();
            state.totalIssuesCreated = (state.totalIssuesCreated || 0) + 1;
            state.lastIssueCreatedAt = new Date().toISOString();
            state.consecutiveNoIssueRuns = 0;
            fs.writeFileSync(statePath, JSON.stringify(state, null, 2));

            core.setOutput('issue_number', response.data.number);
            core.setOutput('issue_type', selectedType);
            core.setOutput('item_id', item.id);
            core.setOutput('issue_created', 'true');
            core.setOutput('reason', 'created');
            core.setOutput('consecutive_no_issue_runs', String(state.consecutiveNoIssueRuns));
            core.setOutput('should_commit', 'true');
            core.setOutput('notify_discord', 'false');

      - name: Commit backlog updates
        id: commit-backlog
        if: steps.create-issue.outputs.should_commit == 'true' && env.AUTOMATION_PR_TOKEN != ''
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          add-paths: |
            data/community-backlog/
          commit-message: 'chore(automation): mark item as issued'
          branch: automation/community-data/hourly-${{ github.run_id }}
          title: 'chore(automation): update community backlog'
          body: Automated update to community backlog state.
          base: main
          delete-branch: true

      - name: Auto-approve and merge automation PR
        if: steps.create-issue.outputs.should_commit == 'true' && env.AUTOMATION_PR_TOKEN != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.AUTOMATION_PR_TOKEN }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER);

            async function sleep(ms) {
              return new Promise(function(resolve) { setTimeout(resolve, ms); });
            }

            if (!prNumber) {
              console.log('No PR was created; nothing to merge');
              return;
            }

            const MAX_RETRIES = 10;
            for (let i = 1; i <= MAX_RETRIES; i += 1) {
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash'
                });
                console.log(`Merged automation PR #${prNumber}`);

                try {
                  const { data: pr } = await github.rest.pulls.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber
                  });
                  const ref = pr && pr.head && pr.head.ref;
                  if (ref) {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${ref}`
                    });
                    console.log(`Deleted automation branch: ${ref}`);
                  }
                } catch (deleteErr) {
                  console.log(`Could not delete automation branch: ${deleteErr.message}`);
                }
                return;
              } catch (e) {
                console.log(`Merge attempt ${i} failed: ${e.message}`);
                if (e.status === 409) {
                  try {
                    await github.rest.pulls.updateBranch({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    console.log(`Requested branch update for PR #${prNumber}`);
                  } catch (updateErr) {
                    console.log(`Could not update branch: ${updateErr.message}`);
                  }
                }
                if (i < MAX_RETRIES) {
                  await sleep(2000);
                }
              }
            }

            throw new Error(`Failed to merge automation PR #${prNumber}`);
        env:
          PR_NUMBER: ${{ steps.commit-backlog.outputs.pull-request-number }}

      - name: Notify Discord if no issues are being created
        if: steps.create-issue.outputs.notify_discord == 'true'
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL || secrets.DISCORD_WEBHOOK }}
          REPO: ${{ github.repository }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          COUNT: ${{ steps.create-issue.outputs.consecutive_no_issue_runs }}
        run: |
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "No Discord webhook configured; skipping"
            exit 0
          fi
          python3 << 'PY' > /tmp/payload.json
          import json
          import os

          repo = os.environ.get('REPO', 'unknown')
          run_url = os.environ.get('RUN_URL', '')
          count = os.environ.get('COUNT', 'unknown')

          payload = {
            "content": f"âš ï¸ Community issue creation has not created any issues for {count} consecutive runs in `{repo}`.\n{run_url}" 
          }
          print(json.dumps(payload))
          PY
          curl -sf -H "Content-Type: application/json" -X POST -d @/tmp/payload.json "$DISCORD_WEBHOOK"
